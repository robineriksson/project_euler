

import numpy as np

def problem1():
    """1. If we list all the natural numbers below 10 that are multiples of
    3 or 5, we get 3,5, 6 and 9. The sum of these multiples is 23.

    Find the sum of all the multiples of 3 or 5 below 1000 .

    """
    arr = np.arange(1,1000,1)
    divn = lambda x, n: x[np.where(np.mod(x, n) == 0 )[0]]
    div3 = divn(arr,3)
    div5 = divn(arr,5)

    # get rid of multiples
    totsum = np.sum(div3[~np.in1d(div3,div5)]) + np.sum(div5)
    print(totsum)

def problem2():
    """2. Each new term in the Fibonacci sequence is generated by adding
    the previous two terms. By starting with 1 and 2, the first 10 terms
    will be:

    1,2,3,5,8,12,21,34,55,89,...

    By considering the terms in the Fibonacci sequence whose values do
    not exceed four million, find the sum of the even-valued terms.

    """


    nmax = 4_000_000
    m = [1,2]
    while True:
        new = m[-2]+m[-1]
        if new < nmax:
            m.append(new)
        else:
            break


    iseven = lambda x: x[np.where(np.mod(x,2)==0)[0]]
    print(np.sum(iseven(np.array(m))))


def problem3():
    """The prime factors of 13195 are 5, 7, 13 and 29.

    What is the largest prime factor of the number 600851475143 ?

    """

    x0 = 600_851_475_143 #130_195
    x = x0
    k = 2
    prime_list = []
    while k <= x:
        if x % k == 0:
            x /= k
            prime_list.append(k)
        k += 1
    assert np.prod(prime_list)==x0, 'something is wrong, should recover x0'
    print(prime_list[-1])

def problem4():
    """A palindromic number reads the same both ways. The largest
    palindrome made from the product of two 2-digit numbers is 9009 =
    91 x 99.

    Find the largest palindrome made from the product of two 3-digit
    numbers.

    """

    # find candidate products
    prod_list = []
    digits=3
    start=10**(digits-1)
    stop=10**digits

    for k in range(start,stop):
        for j in range(start, stop):
            prod_list.append(k*j)
    # find palindromes, can't be sure the last one is the biggest ...
    pal_list = []
    for prod in prod_list:
        if str(prod) == str(prod)[::-1]:
            pal_list.append(prod)

    print(max(pal_list))




from numba import jit

def problem5(kmax=20):
    """2520 is the smallest number that can be divided by each of the
    numbers from 1 to 10 without any remainder.

    What is the smallest positive number that is evenly divisible by
    all of the numbers from 1 to 20 ?

    """
    print(problem5_help(kmax=kmax))


@jit(nopython=True)
def problem5_help(kmax=20):
    x = kmax
    divisors = np.arange(1,kmax+1)
    while True:
        if np.all(np.mod(x,divisors)==0):
            return x
        else:
            x += kmax
