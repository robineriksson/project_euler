

import numpy as np

def problem1():
    """1. If we list all the natural numbers below 10 that are multiples of
    3 or 5, we get 3,5, 6 and 9. The sum of these multiples is 23.

    Find the sum of all the multiples of 3 or 5 below 1000 .

    """
    arr = np.arange(1,1000,1)
    divn = lambda x, n: x[np.where(np.mod(x, n) == 0 )[0]]
    div3 = divn(arr,3)
    div5 = divn(arr,5)

    # get rid of multiples
    totsum = np.sum(div3[~np.in1d(div3,div5)]) + np.sum(div5)
    print(totsum)

def problem2():
    """2. Each new term in the Fibonacci sequence is generated by adding
    the previous two terms. By starting with 1 and 2, the first 10 terms
    will be:

    1,2,3,5,8,12,21,34,55,89,...

    By considering the terms in the Fibonacci sequence whose values do
    not exceed four million, find the sum of the even-valued terms.

    """


    nmax = 4_000_000
    m = [1,2]
    while True:
        new = m[-2]+m[-1]
        if new < nmax:
            m.append(new)
        else:
            break


    iseven = lambda x: x[np.where(np.mod(x,2)==0)[0]]
    print(np.sum(iseven(np.array(m))))


def problem3():
    """The prime factors of 13195 are 5, 7, 13 and 29.

    What is the largest prime factor of the number 600851475143 ?

    """

    x0 = 600_851_475_143 #130_195
    x = x0
    k = 2
    prime_list = []
    while k <= x:
        if x % k == 0:
            x /= k
            prime_list.append(k)
        k += 1
    assert np.prod(prime_list)==x0, 'something is wrong, should recover x0'
    print(prime_list[-1])

def problem4():
    """A palindromic number reads the same both ways. The largest
    palindrome made from the product of two 2-digit numbers is 9009 =
    91 x 99.

    Find the largest palindrome made from the product of two 3-digit
    numbers.

    """

    # find candidate products
    prod_list = []
    digits=3
    start=10**(digits-1)
    stop=10**digits

    for k in range(start,stop):
        for j in range(start, stop):
            prod_list.append(k*j)
    # find palindromes, can't be sure the last one is the biggest ...
    pal_list = []
    for prod in prod_list:
        if str(prod) == str(prod)[::-1]:
            pal_list.append(prod)

    print(max(pal_list))




from numba import jit

def problem5(kmax=20):
    """2520 is the smallest number that can be divided by each of the
    numbers from 1 to 10 without any remainder.

    What is the smallest positive number that is evenly divisible by
    all of the numbers from 1 to 20 ?

    """
    print(problem5_help(kmax=kmax))


@jit(nopython=True)
def problem5_help(kmax=20):
    x = kmax
    divisors = np.arange(1,kmax+1)
    while True:
        if np.all(np.mod(x,divisors)==0):
            return x
        else:
            x += kmax

def problem6(n=10):
    """The sum of the squares of the first ten natural numbers is,

    1^2 + 2^2 + ... + 10^2 = 385.

    he square of the sum of the first ten natural numbers is

    (1 + 2+ ... + 10)^2 = 55^2 = 3025.

    Hence the difference between the sum of the squares of the first ten
    natural numbers and the square of the sum is 3025 - 385 = 2640.

    Find the difference between the sum of the squares of the first
    one hundred natural numbers and the square of the sum.

    """


    x = np.arange(1,n+1)
    print(x.sum()**2 - (x**2).sum())




@jit(nopython=True)
def problem7(stop = 10_001):
    """10_001st prime number?"""
    prime_list = []
    x=2
    while len(prime_list) < stop:
        divisors = np.arange(2,x)
        if np.all(np.mod(x,divisors)>0):
            prime_list.append(x)
        x+=1
    print(f'{len(prime_list)}th prime: {prime_list[-1]}')

def problem8(window=13):
    """The four adjacent digits in the $1000$-digit number that have the
    greatest product are $9 \times 9 \times 8 \times 9 = 5832$.

    7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450
    Find the thirteen adjacent digits in the $1000$-digit number that
    have the greatest product. What is the value of this product?

    """

    x = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

    xs = np.array(list(str(x)),dtype=int)


    n = len(xs)
    prod_list = np.zeros(n-window)
    for i in range(len(prod_list)):
        prod_list[i] = np.prod(xs[i:i+window])

    print(int(np.max(prod_list)))


def problem9():
    """A Pythagorean triplet is a set of three natural numbers, a<b<c , for which, a^2+b^2=c^2

    For example, 3^2+4^2=25=5^2

    There exists exactly one Pythagorean triplet for which a+b+c=1000
    Find the product abc.

    """

    x = np.arange(1,1000)

    # find all combinations
    cand = np.array(np.meshgrid(x,x)).T.reshape(-1,2)
    c = np.reshape(np.sqrt(np.sum(cand**2,axis=1)),(-1,1))

    abc = np.hstack([cand, c])
    # remove impossible pairs
    a_less_b = abc[:,0] < abc[:,1]
    b_less_c = abc[:,1] < abc[:,2]
    abc = abc[a_less_b & b_less_c,:]
    # assumption is that there is only one pair with sum 1000, find that one and print the product.
    print(int(np.prod(abc[np.where(np.sum(abc,axis=1)==1000)[0],:])))
